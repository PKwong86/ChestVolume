# Convert columns to appropriate types
processed_data$Timeframe <- as.integer(processed_data$Timeframe)
processed_data$X <- as.numeric(processed_data$X)
processed_data$Y <- as.numeric(processed_data$Y)
processed_data$Z <- as.numeric(processed_data$Z)
# Sort the data by Timeframe and Marker
processed_data <- processed_data[order(processed_data$Timeframe, processed_data$Marker), ]
# Reset row names
rownames(processed_data) <- NULL
return(processed_data)
}
a <- process_marker_data(data)
View(a)
#' @return A data frame of the same dimensions as `data`, containing the adjusted marker coordinates.
#' @details The function calculates the average center position of all markers within each timeframe and moves each marker towards the center
#' by the specified distance along the line connecting the marker to the center.
#' @examples
#' # Assume 'processed_data' is the data frame from process_marker_data
#' adjusted_data <- adj_position(processed_data, distance = 1)
#' head(adjusted_data)
#'
#' @import dplyr
#' @export
adj_position <- function(data, distance = 1) {
# Load necessary package
library(dplyr)
# Adjust markers for each timeframe
adjusted_data <- data %>%
group_by(Timeframe) %>%
do({
markers_df <- .
# Calculate the center for this timeframe
center_coords <- colMeans(markers_df[, c("X", "Y", "Z")], na.rm = TRUE)
# Function to adjust a single marker
adjust_marker <- function(marker_coords) {
direction_vector <- center_coords - marker_coords
norm <- sqrt(sum(direction_vector ^ 2))
if (norm == 0) {
# If marker is at the center, no adjustment needed
return(marker_coords)
}
unit_vector <- direction_vector / norm
adjusted_coords <- marker_coords + distance * unit_vector
return(adjusted_coords)
}
# Apply the adjustment to all markers
adjusted_coords <- t(apply(markers_df[, c("X", "Y", "Z")], 1, adjust_marker))
# Create a new data frame with adjusted coordinates
markers_df[, c("X", "Y", "Z")] <- adjusted_coords
markers_df
}) %>%
ungroup()
return(adjusted_data)
}
adj_position(a)
b <- adj_position(a)
View(b)
View(a)
View(b)
View(a)
View(b)
library(shiny); runApp('C:/Users/whkwong/Dropbox/sharon lung volumn/shinny5_no_center.R')
View(b)
segments <- list(
UL = c("M01", "M02", "M03", "M04", "M05", "M06", "M07", "M08"),
UR = c("M09", "M10", "M11", "M12", "M13", "M14", "M15", "M16")
)
#'   UR = c("M09", "M10", "M11", "M12", "M13", "M14", "M15", "M16")
#' )
#'
#' # Assume 'adjusted_data' is the data frame with adjusted marker positions
#' volumes_df <- calculate_segment_volumes(adjusted_data, segments)
#' head(volumes_df)
#'
#' @import dplyr
#' @import geometry
#' @export
calculate_segment_volumes <- function(data, segments) {
# Load necessary packages
library(dplyr)
# Initialize a list to store volume data frames
volume_list <- list()
# Loop over each segment
for (segment_name in names(segments)) {
segment_markers <- segments[[segment_name]]
# Filter data for the markers in this segment
segment_data <- data %>%
filter(Marker %in% segment_markers)
# Calculate volumes for each timeframe
segment_volumes <- segment_data %>%
group_by(Timeframe) %>%
do({
df <- .
coords <- as.matrix(df[, c("X", "Y", "Z")])
# Handle cases where convex hull cannot be formed
if (nrow(coords) >= 4) {
hull <- geometry::convhulln(coords, options = "FA")
volume <- hull$vol
} else {
volume <- NA  # Not enough points to form a convex hull in 3D
}
data.frame(Volume = volume)
}) %>%
ungroup() %>%
mutate(Segment = segment_name)
# Append to the list
volume_list[[segment_name]] <- segment_volumes
}
# Combine all volume data frames
volumes_df <- bind_rows(volume_list)
# Reorder columns
volumes_df <- volumes_df[, c("Timeframe", "Segment", "Volume")]
# Arrange data
volumes_df <- volumes_df %>%
arrange(Timeframe, Segment)
return(volumes_df)
}
calculate_segment_volumes(b, segments)
#'   UR = c("M09", "M10", "M11", "M12", "M13", "M14", "M15", "M16")
#' )
#'
#' # Assume 'adjusted_data' is the data frame with adjusted marker positions
#' volumes_df <- calculate_segment_volumes(adjusted_data, segments)
#' head(volumes_df)
#'
#' @import dplyr
#' @import geometry
#' @export
calculate_segment_volumes <- function(data, segments) {
# Load necessary packages
library(dplyr)
# Initialize a list to store volume data frames
volume_list <- list()
# Loop over each segment
for (segment_name in names(segments)) {
segment_markers <- segments[[segment_name]]
# Filter data for the markers in this segment
segment_data <- data %>%
filter(Marker %in% segment_markers)
# Calculate volumes for each timeframe
segment_volumes <- segment_data %>%
group_by(Timeframe) %>%
do({
df <- .
coords <- as.matrix(df[, c("X", "Y", "Z")])/10
# Handle cases where convex hull cannot be formed
if (nrow(coords) >= 4) {
hull <- geometry::convhulln(coords, options = "FA")
volume <- hull$vol
} else {
volume <- NA  # Not enough points to form a convex hull in 3D
}
data.frame(Volume = volume)
}) %>%
ungroup() %>%
mutate(Segment = segment_name)
# Append to the list
volume_list[[segment_name]] <- segment_volumes
}
# Combine all volume data frames
volumes_df <- bind_rows(volume_list)
# Reorder columns
volumes_df <- volumes_df[, c("Timeframe", "Segment", "Volume")]
# Arrange data
volumes_df <- volumes_df %>%
arrange(Timeframe, Segment)
return(volumes_df)
}
calculate_segment_volumes(b, segments)
#' # Coordinates are in mm; we'll convert to cm by default
#' volumes_df <- calculate_segment_volumes(adjusted_data, segments)
#' head(volumes_df)
#'
#' # If coordinates are already in cm, set unit_conversion to 1
#' volumes_df_cm <- calculate_segment_volumes(adjusted_data, segments, unit_conversion = 1)
#'
#' @import dplyr
#' @import geometry
#' @export
calculate_segment_volumes <- function(data, segments, unit_conversion = 0.1) {
# Load necessary packages
library(dplyr)
# Apply unit conversion to coordinates
data <- data %>%
mutate(
X = X * unit_conversion,
Y = Y * unit_conversion,
Z = Z * unit_conversion
)
# Initialize a list to store volume data frames
volume_list <- list()
# Loop over each segment
for (segment_name in names(segments)) {
segment_markers <- segments[[segment_name]]
# Filter data for the markers in this segment
segment_data <- data %>%
filter(Marker %in% segment_markers)
# Calculate volumes for each timeframe
segment_volumes <- segment_data %>%
group_by(Timeframe) %>%
do({
df <- .
coords <- as.matrix(df[, c("X", "Y", "Z")])
# Handle cases where convex hull cannot be formed
if (nrow(coords) >= 4) {
hull <- geometry::convhulln(coords, options = "FA")
volume <- hull$vol
} else {
volume <- NA  # Not enough points to form a convex hull in 3D
}
data.frame(Volume = volume)
}) %>%
ungroup() %>%
mutate(Segment = segment_name)
# Append to the list
volume_list[[segment_name]] <- segment_volumes
}
# Combine all volume data frames
volumes_df <- bind_rows(volume_list)
# Reorder columns
volumes_df <- volumes_df[, c("Timeframe", "Segment", "Volume")]
# Arrange data
volumes_df <- volumes_df %>%
arrange(Timeframe, Segment)
return(volumes_df)
}
calculate_segment_volumes(b, segments)
#'   UR = c("M05", "M06", "M07", "M08"),
#'   LL = c("M09", "M10", "M11", "M12"),
#'   LR = c("M13", "M14", "M15", "M16")
#' )
#' # Plot the 'UL' segment at timeframe 1
#' plot <- plot_chest_3d(adjusted_data, segments, selected_segment = "UL", timeframe = 1)
#' # Display the plot
#' plot
#' @import plotly
#' @export
plot_chest_3d <- function(data, segments, selected_segment, timeframe = NULL,
point_size = 5, highlight_color = 'red', marker_color = 'blue') {
# Load necessary package
library(plotly)
# Validate inputs
if (!selected_segment %in% names(segments)) {
stop("Selected segment not found in the segments list.")
}
# Use the first timeframe if not specified
if (is.null(timeframe)) {
timeframe <- min(data$Timeframe, na.rm = TRUE)
}
# Filter data for the specified timeframe
data_time <- subset(data, Timeframe == timeframe)
# Identify markers in the selected segment
selected_markers <- segments[[selected_segment]]
# Create a color vector for all markers
data_time$Color <- marker_color
data_time$Size <- point_size
# Highlight the selected segment markers
data_time$Color[data_time$Marker %in% selected_markers] <- highlight_color
data_time$Size[data_time$Marker %in% selected_markers] <- point_size * 1.5  # Make highlighted markers larger
# Create 3D scatter plot
plot <- plot_ly(data_time, x = ~X, y = ~Y, z = ~Z, type = 'scatter3d', mode = 'markers',
marker = list(size = ~Size, color = ~Color),
text = ~paste('Marker:', Marker),
hoverinfo = 'text')
# Add layout settings
plot <- plot %>%
layout(
scene = list(
xaxis = list(title = 'X'),
yaxis = list(title = 'Y'),
zaxis = list(title = 'Z'),
camera = list(eye = list(x = 1.25, y = 1.25, z = 1.25))
),
title = paste('3D Chest Markers at Timeframe', timeframe, '- Highlighted Segment:', selected_segment)
)
return(plot)
}
plot_chest_3d(a, segments, selected_segment = 'UL')
#'   LL = c("M09", "M10", "M11", "M12"),
#'   LR = c("M13", "M14", "M15", "M16")
#' )
#' # Plot the 'UL' segment at timeframe 1
#' plot <- plot_chest_3d(adjusted_data, segments, selected_segment = "UL", timeframe = 1)
#' # Display the plot
#' plot
#' @import plotly
#' @import geometry
#' @export
plot_chest_3d <- function(data, segments, selected_segment, timeframe = NULL,
point_size = 5, highlight_color = 'red', marker_color = 'blue') {
# Load necessary packages
library(plotly)
library(geometry)
# Validate inputs
if (!selected_segment %in% names(segments)) {
stop("Selected segment not found in the segments list.")
}
# Use the first timeframe if not specified
if (is.null(timeframe)) {
timeframe <- min(data$Timeframe, na.rm = TRUE)
}
# Filter data for the specified timeframe
data_time <- subset(data, Timeframe == timeframe)
# Identify markers in the selected segment
selected_markers <- segments[[selected_segment]]
# Create a color vector for all markers
data_time$Color <- marker_color
data_time$Size <- point_size
# Highlight the selected segment markers
data_time$Color[data_time$Marker %in% selected_markers] <- highlight_color
data_time$Size[data_time$Marker %in% selected_markers] <- point_size * 1.5  # Make highlighted markers larger
# Create 3D scatter plot
plot <- plot_ly(data_time, x = ~X, y = ~Y, z = ~Z, type = 'scatter3d', mode = 'markers',
marker = list(size = ~Size, color = ~Color),
text = ~paste('Marker:', Marker),
hoverinfo = 'text')
# Compute convex hull for the selected segment markers
segment_data <- data_time[data_time$Marker %in% selected_markers, ]
coords <- as.matrix(segment_data[, c("X", "Y", "Z")])
if (nrow(coords) >= 4) {
# Compute the convex hull
hull <- convhulln(coords, output.options = TRUE)
# Extract vertices and simplices
vertices <- coords
simplices <- hull$hull  # Indices of the vertices forming the convex hull faces
# Adjust indices for 0-based indexing in plotly
simplices_zero_based <- simplices - 1
# Add convex hull mesh to the plot
plot <- plot %>%
add_trace(
x = vertices[, 1],
y = vertices[, 2],
z = vertices[, 3],
i = simplices_zero_based[, 1],
j = simplices_zero_based[, 2],
k = simplices_zero_based[, 3],
type = 'mesh3d',
name = paste('Convex Hull -', selected_segment),
facecolor = highlight_color,
opacity = 0.5,
showlegend = FALSE
)
} else {
warning("Not enough points to form a convex hull for the selected segment.")
}
# Add layout settings
plot <- plot %>%
layout(
scene = list(
xaxis = list(title = 'X'),
yaxis = list(title = 'Y'),
zaxis = list(title = 'Z'),
camera = list(eye = list(x = 1.25, y = 1.25, z = 1.25))
),
title = paste('3D Chest Markers at Timeframe', timeframe, '- Highlighted Segment:', selected_segment)
)
return(plot)
}
plot_chest_3d(a, segments, selected_segment = 'UL')
devtools::document()
plot_chest_3d(a, segments, selected_segment = 'UR')
plot_chest_3d(a, segments, selected_segment = c('UR','UL'))
#'   LL = c("M09", "M10", "M11", "M12"),
#'   LR = c("M13", "M14", "M15", "M16")
#' )
#' # Plot the 'UL' segment at timeframe 1
#' plot <- plot_chest_3d(adjusted_data, segments, selected_segment = "UL", timeframe = 1)
#' # Display the plot
#' plot
#' @import plotly
#' @import geometry
#' @export
plot_chest_3d <- function(data, segments, selected_segment, timeframe = NULL,
point_size = 5, highlight_color = 'red', marker_color = 'blue') {
# Load necessary packages
library(plotly)
library(geometry)
# Validate inputs
if (!selected_segment %in% names(segments)) {
stop("Selected segment not found in the segments list.")
}
# Use the first timeframe if not specified
if (is.null(timeframe)) {
timeframe <- min(data$Timeframe, na.rm = TRUE)
}
# Filter data for the specified timeframe
data_time <- subset(data, Timeframe == timeframe)
# Identify markers in the selected segment
selected_markers <- segments[[selected_segment]]
# Create a color vector for all markers
data_time$Color <- marker_color
data_time$Size <- point_size
# Highlight the selected segment markers
data_time$Color[data_time$Marker %in% selected_markers] <- highlight_color
data_time$Size[data_time$Marker %in% selected_markers] <- point_size * 1.5  # Make highlighted markers larger
# Create 3D scatter plot
plot <- plot_ly(data_time, x = ~X, y = ~Y, z = ~Z,
type = 'scatter3d', mode = 'markers',
marker = list(size = ~Size, color = ~Color),
text = ~paste('Marker:', Marker),
hoverinfo = 'text')
# Compute convex hull for the selected segment markers
segment_data <- data_time[data_time$Marker %in% selected_markers, ]
coords <- as.matrix(segment_data[, c("X", "Y", "Z")])
if (nrow(coords) >= 4) {
# Compute the convex hull
hull <- convhulln(coords, output.options = TRUE)
# Extract vertices and simplices
vertices <- coords
simplices <- hull$hull  # Indices of the vertices forming the convex hull faces
# Adjust indices for 0-based indexing in plotly
simplices_zero_based <- simplices - 1
# Add convex hull mesh to the plot
plot <- plot %>%
add_trace(
x = vertices[, 1],
y = vertices[, 2],
z = vertices[, 3],
i = simplices_zero_based[, 1],
j = simplices_zero_based[, 2],
k = simplices_zero_based[, 3],
type = 'mesh3d',
name = paste('Convex Hull -', selected_segment),
color = highlight_color,
opacity = 0.5,
showlegend = FALSE,
inherit = FALSE  # Prevent inheritance of attributes
)
} else {
warning("Not enough points to form a convex hull for the selected segment.")
}
# Add layout settings
plot <- plot %>%
layout(
scene = list(
xaxis = list(title = 'X'),
yaxis = list(title = 'Y'),
zaxis = list(title = 'Z'),
camera = list(eye = list(x = 1.25, y = 1.25, z = 1.25))
),
title = paste('3D Chest Markers at Timeframe', timeframe, '- Highlighted Segment:', selected_segment)
)
return(plot)
}
plot_chest_3d(a, segments, selected_segment = 'UL')
segments <- list(
UL = c("M01", "M02", "M03", "M04", "M05", "M06", "M07", "M08",'M25'),
UR = c("M09", "M10", "M11", "M12", "M13", "M14", "M15", "M16")
)
segments <- list(
UL = c("M01", "M02", "M03", "M04", "M05", "M06", "M07", "M08",'M25'),
UR = c("M09", "M10", "M11", "M12", "M13", "M14", "M15", "M16")
)
plot_chest_3d(a, segments, selected_segment = 'UL')
segments <- list(
UL = c("M01", "M02", "M03", "M04", "M05", "M06", "M07", "M08",'M18'),
UR = c("M09", "M10", "M11", "M12", "M13", "M14", "M15", "M16")
)
calculate_segment_volumes(b, segments)
plot_chest_3d(a, segments, selected_segment = 'UL')
#'   \item Subsequent columns contain the marker names belonging to each segment.
#' }
#' Missing marker entries can be left blank or filled with \code{NA}.
#' @examples
#' \dontrun{
#' # Assume 'segments.xlsx' is your Excel file with segment definitions
#' segments <- read_segment_definitions("segments.xlsx")
#' }
#' @import readxl
#' @export
read_segment_definitions <- function(filepath) {
# Load necessary package
library(readxl)
# Read the Excel file
segment_data <- read_excel(filepath, col_names = FALSE)
# Ensure there is at least one column
if (ncol(segment_data) < 2) {
stop("The Excel file must have at least two columns: one for segment names and at least one for marker names.")
}
# Initialize the segments list
segments <- list()
# Loop over each row to extract segment names and marker names
for (i in 1:nrow(segment_data)) {
segment_name <- as.character(segment_data[i, 1])
marker_names <- as.character(segment_data[i, -1])
# Remove NA and empty strings
marker_names <- marker_names[!is.na(marker_names) & marker_names != ""]
# Add to the segments list
segments[[segment_name]] <- marker_names
}
return(segments)
}
setwd("C:/Users/whkwong/Dropbox/r script/ChestVolume/ChestVolume/data")
a <- read_segment_definitions('segment_def.xlsx')
View(a)
View(segments)
calculate_segment_volumes(b, a)
View(a)
vol <- calculate_segment_volumes(b, a)
View(vol)
plot_chest_3d(b, a, selected_segment = 'UL')
plot_chest_3d(b, a, selected_segment = 'LL')
plot_chest_3d(b, a, selected_segment = 'LR')
read_segment_definitions('segment_def.xlsx')
plot_chest_3d(b, a, selected_segment = 'LR')
a <- read_segment_definitions('segment_def.xlsx')
plot_chest_3d(b, a, selected_segment = 'LR')
plot_chest_3d(b, a, selected_segment = 'UR')
devtools::document()
setwd("C:/Users/whkwong/Dropbox/r script/ChestVolume/ChestVolume")
setwd("C:/Users/whkwong/Dropbox/r script/ChestVolume/ChestVolume")
devtools::document()
