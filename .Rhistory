hoverinfo = 'text')
# Compute convex hull for the selected segment markers
segment_data <- data_time[data_time$Marker %in% selected_markers, ]
coords <- as.matrix(segment_data[, c("X", "Y", "Z")])
if (nrow(coords) >= 4) {
# Compute the convex hull
hull <- convhulln(coords, output.options = TRUE)
# Extract vertices and simplices
vertices <- coords
simplices <- hull$hull  # Indices of the vertices forming the convex hull faces
# Adjust indices for 0-based indexing in plotly
simplices_zero_based <- simplices - 1
# Add convex hull mesh to the plot
plot <- plot %>%
add_trace(
x = vertices[, 1],
y = vertices[, 2],
z = vertices[, 3],
i = simplices_zero_based[, 1],
j = simplices_zero_based[, 2],
k = simplices_zero_based[, 3],
type = 'mesh3d',
name = paste('Convex Hull -', selected_segment),
facecolor = highlight_color,
opacity = 0.5,
showlegend = FALSE
)
} else {
warning("Not enough points to form a convex hull for the selected segment.")
}
# Add layout settings
plot <- plot %>%
layout(
scene = list(
xaxis = list(title = 'X'),
yaxis = list(title = 'Y'),
zaxis = list(title = 'Z'),
camera = list(eye = list(x = 1.25, y = 1.25, z = 1.25))
),
title = paste('3D Chest Markers at Timeframe', timeframe, '- Highlighted Segment:', selected_segment)
)
return(plot)
}
plot_chest_3d(df_a, seg, selected_segment = 'UL', 10)
#'   LL = c("M09", "M10", "M11", "M12"),
#'   LR = c("M13", "M14", "M15", "M16")
#' )
#' # Plot the 'UL' segment at timeframe 1
#' plot <- plot_chest_3d(adjusted_data, segments, selected_segment = "UL", timeframe = 1)
#' # Display the plot
#' plot
#' @import plotly
#' @import geometry
#' @export
plot_chest_3d <- function(data, segments, selected_segment, timeframe = NULL,
point_size = 5, highlight_color = 'red', marker_color = 'blue') {
# Load necessary packages
library(plotly)
library(geometry)
# Validate inputs
if (!selected_segment %in% names(segments)) {
stop("Selected segment not found in the segments list.")
}
# Use the first timeframe if not specified
if (is.null(timeframe)) {
timeframe <- min(data$Timeframe, na.rm = TRUE)
}
# Filter data for the specified timeframe
data_time <- subset(data, Timeframe == timeframe)
# Identify markers in the selected segment
selected_markers <- segments[[selected_segment]]
# Create a color vector for all markers
data_time$Color <- marker_color
data_time$Size <- point_size
# Highlight the selected segment markers
data_time$Color[data_time$Marker %in% selected_markers] <- highlight_color
data_time$Size[data_time$Marker %in% selected_markers] <- point_size * 1.5  # Make highlighted markers larger
# Create 3D scatter plot
plot <- plot_ly(data_time, x = ~X, y = ~Y, z = ~Z, type = 'scatter3d', mode = 'markers',
marker = list(size = ~Size, color = ~Color),
text = ~paste('Marker:', Marker),
hoverinfo = 'text')
# Compute convex hull for the selected segment markers
segment_data <- data_time[data_time$Marker %in% selected_markers, ]
coords <- as.matrix(segment_data[, c("X", "Y", "Z")])
if (nrow(coords) >= 4) {
# Compute the convex hull
hull <- convhulln(coords, output.options = TRUE)
# Extract vertices and simplices
vertices <- coords
simplices <- hull$hull  # Indices of the vertices forming the convex hull faces
# Adjust indices for 0-based indexing in plotly
simplices_zero_based <- simplices - 1
# Add convex hull mesh to the plot
plot <- plot %>%
add_trace(
x = vertices[, 1],
y = vertices[, 2],
z = vertices[, 3],
i = simplices_zero_based[, 1],
j = simplices_zero_based[, 2],
k = simplices_zero_based[, 3],
type = 'mesh3d',
name = paste('Convex Hull -', selected_segment),
facecolor = highlight_color,
opacity = 0.5,
showlegend = FALSE, inherit = F
)
} else {
warning("Not enough points to form a convex hull for the selected segment.")
}
# Add layout settings
plot <- plot %>%
layout(
scene = list(
xaxis = list(title = 'X'),
yaxis = list(title = 'Y'),
zaxis = list(title = 'Z'),
camera = list(eye = list(x = 1.25, y = 1.25, z = 1.25))
),
title = paste('3D Chest Markers at Timeframe', timeframe, '- Highlighted Segment:', selected_segment)
)
return(plot)
}
plot_chest_3d(df_a, seg, selected_segment = 'UL', 10)
plot_2d_volume(vol, Segment)
View(vol)
View(vol)
plot_2d_volume(vol, Segment)
plot_2d_volume(vol)
plot_2d_volume(vol, segment_names = 'UL')
plot_2d_volume(vol, segment_names = 'Segment')
#' volume_data <- data.frame(
#'   frame = time_frames,
#'   UL = runif(100, min = 100, max = 150),
#'   UR = runif(100, min = 120, max = 160),
#'   LL = runif(100, min = 90, max = 140),
#'   LR = runif(100, min = 110, max = 170)
#' )
#' segment_names <- c("UL", "UR", "LL", "LR")
#' plot_volume_change_by_segment(volume_data, segment_names)
#'
plot_2d_volume <- function(volume_data, segment_names = 'Segment', title = "Volume Change by Segment") {
# Ensure 'frame' column is present
if (!"Timeframe" %in% names(volume_data)) {
stop("The 'volume_data' must contain a 'Timeframe' column for time points.")
}
# Ensure segment names match column names in volume_data
if (!all(segment_names %in% colnames(volume_data))) {
stop("All provided segment names must match column names in 'volume_data'.")
}
# Create the ggplot
ggplot(volume_data, aes(x = Timeframe, y = Volume, color = Segment)) +
geom_line(size = 1) +
labs(x = "Timeframe", y = "Volume") +
theme_minimal() +
theme(
plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
axis.title = element_text(size = 12),
axis.text = element_text(size = 10)
)
}
plot_2d_volume(vol, segment_names = 'Segment')
#' volume_data <- data.frame(
#'   frame = time_frames,
#'   UL = runif(100, min = 100, max = 150),
#'   UR = runif(100, min = 120, max = 160),
#'   LL = runif(100, min = 90, max = 140),
#'   LR = runif(100, min = 110, max = 170)
#' )
#' segment_names <- c("UL", "UR", "LL", "LR")
#' plot_volume_change_by_segment(volume_data, segment_names)
#'
plot_2d_volume <- function(volume_data, segment_names = 'Segment', title = "Volume Change by Segment") {
# Ensure 'frame' column is present
if (!"Timeframe" %in% names(volume_data)) {
stop("The 'volume_data' must contain a 'Timeframe' column for time points.")
}
# Ensure segment names match column names in volume_data
if (!all(segment_names %in% colnames(volume_data))) {
stop("All provided segment names must match column names in 'volume_data'.")
}
# Create the ggplot
ggplot(volume_data, aes(x = Timeframe, y = Volume, color = Segment)) +
geom_line(linewidth = 1) +
labs(x = "Timeframe", y = "Volume") +
theme_minimal() +
theme(
plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
axis.title = element_text(size = 12),
axis.text = element_text(size = 10)
)
}
plot_2d_volume(vol, segment_names = 'Segment')
library(ChestVolume)
data("sample_data")
df<-process_marker_data(sample_data)
df_a <- adj_position(df)
seg <- read_segment_definitions('segment_def.xlsx')
vol <- calculate_segment_volumes(df_a, seg)
plot_chest_3d(df_a, seg, selected_segment = 'UL', 10)
plot_2d_volume(vol, segment_names = 'Segment')
library(ChestVolume)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(ChestVolume)
View(vol)
View(plot_2d_volume)
View(plot_2d_volume)
raw_data <- data('sample_data')
processed_data <- process_marker_data(raw_data, convert_to_cm = TRUE)
raw_data <- data('sample_data')
processed_data <- process_marker_data(raw_data, convert_to_cm = TRUE)
raw_data <- data('sample_data')
raw_data <- data(sample_data)
raw_data <- data(sample_data)
raw_data <- data('sample_data')
data('sample_data')
force(sample_data)
data(sample_data)
processed_data <- process_marker_data(sample_data, convert_to_cm = TRUE)
head(processed_data)
library(ChestVolume)
raw_data <- data(sample_data)
# Step 1: Process the marker data and convert from mm to cm
processed_data <- process_marker_data(raw_data, convert_to_cm = TRUE)
data(sample_data)
# Step 1: Process the marker data and convert from mm to cm
processed_data <- process_marker_data(raw_data, convert_to_cm = TRUE)
# Step 1: Process the marker data and convert from mm to cm
processed_data <- process_marker_data(sample_data, convert_to_cm = TRUE)
# Step 2: Adjust the marker positions by moving them 1 cm toward the chest center
adjusted_data <- adj_position(processed_data, distance = 1)
# Step 3: Define the chest segments (example with one segment)
segments <- list(
upper_left = c("M01", "M02", "M04", "M05","M07", "M08","M10", "M11")
)
# Step 4: Calculate the chest segment volumes
volumes <- calculate_convex_hull_volume(adjusted_data, segments)
devtools::document()
devtools::document()
library(ChestVolume)
raw_data <- data(sample_data)
# Step 1: Process the marker data and convert from mm to cm
processed_data <- process_marker_data(raw_data, convert_to_cm = TRUE)
raw_data <- data(sample_data)
# Step 1: Process the marker data and convert from mm to cm
processed_data <- process_marker_data(raw_data, convert_to_cm = TRUE)
data(sample_data)
# Step 1: Process the marker data and convert from mm to cm
processed_data <- process_marker_data(sample_data, convert_to_cm = TRUE)
# Step 2: Adjust the marker positions by moving them 1 cm toward the chest center
adjusted_data <- adj_position(processed_data, distance = 1)
# Step 3: Define the chest segments (example with one segment)
segments <- list(
upper_left = c("M01", "M02", "M04", "M05","M07", "M08","M10", "M11")
)
# Step 4: Calculate the chest segment volumes
volumes <- calculate_volume(adjusted_data, segments)
# Step 4: Calculate the chest segment volumes
volumes <- calculate_volumes(adjusted_data, segments)
# Step 5: Visualize the chest expansion in 3D
plot_chest_3d(adjusted_data, segments)
View(adjusted_data)
# Step 6: Plot the chest volume changes over time
plot_volume_change_by_segment(volumes, segment_names = c("upper_left", "upper_right"))
# Step 6: Plot the chest volume changes over time
plot_2d_volume(volumes, segment_names = c("upper_left", "upper_right"))
View(volumes)
# Step 6: Plot the chest volume changes over time
plot_2d_volume(volumes, Segments)
# Step 3: Define the chest segments (example with one segment)
segments <- list(
upper_left = c("M01", "M02", "M04", "M05","M07", "M08","M10", "M11")
)
# Step 6: Plot the chest volume changes over time
plot_2d_volume(volumes, Segments)
# Step 6: Plot the chest volume changes over time
plot_2d_volume(volumes, Segment)
# Step 6: Plot the chest volume changes over time
plot_2d_volume(volumes, segment_names = Segment)
View(volumes)
View(volumes)
# Step 6: Plot the chest volume changes over time
plot_2d_volume(volumes, segment_names = Segment)
View(volumes)
data("sample_data")
df<-process_marker_data(sample_data)
df_a <- adj_position(df)
seg <- read_segment_definitions('segment_def.xlsx')
vol <- calculate_volumes(df_a, seg)
vol <- calculate_volumes(df_a, segments)
plot_chest_3d(df_a, seg, selected_segment = 'UL', 10)
plot_chest_3d(df_a, segments, selected_segment = 'UL', 10)
View(segments)
plot_chest_3d(df_a, segments, selected_segment = 'upper_left', 10)
# Example sample input data
data(sample_data)
# Step 1: Process the marker data and convert from mm to cm
processed_data <- process_marker_data(sample_data, convert_to_cm = TRUE)
# Step 2: Adjust the marker positions by moving them 1 cm toward the chest center
adjusted_data <- adj_position(processed_data, distance = 1)
# Step 3: Define the chest segments (example with one segment)
segments <- list(
upper_left = c("M01", "M02", "M04", "M05","M07", "M08","M10", "M11")
)
# Step 4: Calculate the chest segment volumes
volumes <- calculate_volumes(adjusted_data, segments)
# Step 5: Visualize the chest expansion in 3D
plot_chest_3d(adjusted_data, segments)
# Step 4: Calculate the chest segment volumes
volumes <- calculate_volumes(adjusted_data, segments, selected_segment = 'upper_left')
# Step 5: Visualize the chest expansion in 3D
plot_chest_3d(adjusted_data, segments, selected_segment = 'upper_left')
# Step 6: Plot the chest volume changes over time
plot_volume_change_by_segment(volumes, segment_names = c("upper_left", "upper_right"))
# Step 6: Plot the chest volume changes over time
plot_2d_volume(volumes, segment_names = c("upper_left", "upper_right"))
View(volumes)
# Step 6: Plot the chest volume changes over time
plot_2d_volume(volumes, segment_names = c("upper_left"))
# Step 6: Plot the chest volume changes over time
plot_2d_volume(volumes, segment_names = c("upper_left"))
# Step 6: Plot the chest volume changes over time
plot_2d_volume(volumes, segment_names = "upper_left")
View(volumes)
View(volumes)
plot_2d_volume(vol, Segment)
# Step 6: Plot the chest volume changes over time
plot_2d_volume(volumes, Segment)
View(volumes)
set.seed(123)
volume_data <- data.frame(
Timeframe = 1:100,
Volume = runif(100, min = 100, max = 150),
Segment = 'UL'
)
plot_2d_volume(volume_data, segment_names = 'Segment')
View(volume_data)
# Step 6: Plot the chest volume changes over time
plot_2d_volume(volumes, 'Segment')
data(sample_data)
library(ChestVolume)
if (!requireNamespace("devtools", quietly = TRUE)) {
install.packages("devtools")
}
devtools::install_github("YourUsername/ChestVolume")
if (!requireNamespace("devtools", quietly = TRUE)) {
install.packages("devtools")
}
devtools::install_github("PKwong86/ChestVolume")
library(ChestVolume)
kable(head(sample_data[, 1:4]), "pipe")
library(ChestVolume)
kable(head(sample_data[, 1:4]), "pipe")
library(ChestVolume)
knitr::kable(head(sample_data[, 1:4]), "pipe")
library(ChestVolume)
knitr::kable(head(sample_data[, 1:6]), "pipe")
install.packages("xfun")
install.packages(c("admisc", "afex", "backports", "BayesFactor", "bayestestR", "BH", "bit", "bitops", "brio", "broom", "broom.helpers", "BWStest", "cachem", "callr", "checkmate", "cli", "coda", "colorspace", "commonmark", "correlation", "corrplot", "cowplot", "curl", "data.table", "datawizard", "DBI", "dbplyr", "desc", "DescTools", "deSolve", "digest", "dipsaus", "dplyr", "DT", "e1071", "effectsize", "emmeans", "eRm", "estimability", "Exact", "expm", "FactoMineR", "fansi", "farver", "fastmap", "filearray", "freesurferformats", "fs", "future", "future.apply", "geometry", "gert", "ggrepel", "ggsci", "ggside", "ggstatsplot", "globals", "glue", "gmp", "gsw", "gt", "gtsummary", "haven", "hdf5r", "htmltools", "httpuv", "igraph", "insight", "jsonlite", "jtools", "kableExtra", "keras", "labelled", "later", "lavaan", "leaps", "listenv", "lme4", "markdown", "MatrixModels", "matrixStats", "mc2d", "metafor", "minqa", "modelbased", "modelsummary", "msm", "multcomp", "multcompView", "mvtnorm", "nloptr", "oce", "pak", "paletteer", "parallelly", "parameters", "patchwork", "pbdZMQ", "pbkrtest", "performance", "pkgbuild", "pkgfilecache", "pkgload", "PMCMRplus", "prismatic", "pROC", "processx", "profvis", "promises", "ps", "psych", "quantreg", "R.oo", "ragg", "ravetools", "Rcpp", "RcppArmadillo", "RcppEigen", "RcppParallel", "reactR", "readr", "remotes", "renv", "report", "repr", "reprex", "reticulate", "rlang", "Rmpfr", "RNifti", "RNiftyReg", "rprojroot", "rsconnect", "rstantools", "rstudioapi", "Rvcg", "rvest", "s2", "sandwich", "sass", "see", "servr", "sf", "shiny", "signal", "SparseM", "statsExpressions", "stringi", "SuppDists", "svglite", "systemfonts", "tables", "TAM", "targets", "tensorflow", "testthat", "textshaping", "tfruns", "tidyr", "timechange", "utf8", "uuid", "V8", "vctrs", "viridis", "vroom", "waldo", "waveslim", "wk", "writexl", "WRS2", "XML", "xml2", "yaml"))
install.packages(c("admisc", "afex", "backports", "BayesFactor", "bayestestR", "BH", "bit", "bitops", "brio", "broom", "broom.helpers", "BWStest", "cachem", "callr", "checkmate", "cli", "coda", "colorspace", "commonmark", "correlation", "corrplot", "cowplot", "curl", "data.table", "datawizard", "DBI", "dbplyr", "desc", "DescTools", "deSolve", "digest", "dipsaus", "dplyr", "DT", "e1071", "effectsize", "emmeans", "eRm", "estimability", "Exact", "expm", "FactoMineR", "fansi", "farver", "fastmap", "filearray", "freesurferformats", "fs", "future", "future.apply", "geometry", "gert", "ggrepel", "ggsci", "ggside", "ggstatsplot", "globals", "glue", "gmp", "gsw", "gt", "gtsummary", "haven", "hdf5r", "htmltools", "httpuv", "igraph", "insight", "jsonlite", "jtools", "kableExtra", "keras", "labelled", "later", "lavaan", "leaps", "listenv", "lme4", "markdown", "MatrixModels", "matrixStats", "mc2d", "metafor", "minqa", "modelbased", "modelsummary", "msm", "multcomp", "multcompView", "mvtnorm", "nloptr", "oce", "pak", "paletteer", "parallelly", "parameters", "patchwork", "pbdZMQ", "pbkrtest", "performance", "pkgbuild", "pkgfilecache", "pkgload", "PMCMRplus", "prismatic", "pROC", "processx", "profvis", "promises", "ps", "psych", "quantreg", "R.oo", "ragg", "ravetools", "Rcpp", "RcppArmadillo", "RcppEigen", "RcppParallel", "reactR", "readr", "remotes", "renv", "report", "repr", "reprex", "reticulate", "rlang", "Rmpfr", "RNifti", "RNiftyReg", "rprojroot", "rsconnect", "rstantools", "rstudioapi", "Rvcg", "rvest", "s2", "sandwich", "sass", "see", "servr", "sf", "shiny", "signal", "SparseM", "statsExpressions", "stringi", "SuppDists", "svglite", "systemfonts", "tables", "TAM", "targets", "tensorflow", "testthat", "textshaping", "tfruns", "tidyr", "timechange", "utf8", "uuid", "V8", "vctrs", "viridis", "vroom", "waldo", "waveslim", "wk", "writexl", "WRS2", "XML", "xml2", "yaml"))
install.packages(c("admisc", "afex", "backports", "BayesFactor", "bayestestR", "BH", "bit", "bitops", "brio", "broom", "broom.helpers", "BWStest", "cachem", "callr", "checkmate", "cli", "coda", "colorspace", "commonmark", "correlation", "corrplot", "cowplot", "curl", "data.table", "datawizard", "DBI", "dbplyr", "desc", "DescTools", "deSolve", "digest", "dipsaus", "dplyr", "DT", "e1071", "effectsize", "emmeans", "eRm", "estimability", "Exact", "expm", "FactoMineR", "fansi", "farver", "fastmap", "filearray", "freesurferformats", "fs", "future", "future.apply", "geometry", "gert", "ggrepel", "ggsci", "ggside", "ggstatsplot", "globals", "glue", "gmp", "gsw", "gt", "gtsummary", "haven", "hdf5r", "htmltools", "httpuv", "igraph", "insight", "jsonlite", "jtools", "kableExtra", "keras", "labelled", "later", "lavaan", "leaps", "listenv", "lme4", "markdown", "MatrixModels", "matrixStats", "mc2d", "metafor", "minqa", "modelbased", "modelsummary", "msm", "multcomp", "multcompView", "mvtnorm", "nloptr", "oce", "pak", "paletteer", "parallelly", "parameters", "patchwork", "pbdZMQ", "pbkrtest", "performance", "pkgbuild", "pkgfilecache", "pkgload", "PMCMRplus", "prismatic", "pROC", "processx", "profvis", "promises", "ps", "psych", "quantreg", "R.oo", "ragg", "ravetools", "Rcpp", "RcppArmadillo", "RcppEigen", "RcppParallel", "reactR", "readr", "remotes", "renv", "report", "repr", "reprex", "reticulate", "rlang", "Rmpfr", "RNifti", "RNiftyReg", "rprojroot", "rsconnect", "rstantools", "rstudioapi", "Rvcg", "rvest", "s2", "sandwich", "sass", "see", "servr", "sf", "shiny", "signal", "SparseM", "statsExpressions", "stringi", "SuppDists", "svglite", "systemfonts", "tables", "TAM", "targets", "tensorflow", "testthat", "textshaping", "tfruns", "tidyr", "timechange", "utf8", "uuid", "V8", "vctrs", "viridis", "vroom", "waldo", "waveslim", "wk", "writexl", "WRS2", "XML", "xml2", "yaml"))
install.packages(c("admisc", "afex", "backports", "BayesFactor", "bayestestR", "BH", "bit", "bitops", "brio", "broom", "broom.helpers", "BWStest", "cachem", "callr", "checkmate", "cli", "coda", "colorspace", "commonmark", "correlation", "corrplot", "cowplot", "curl", "data.table", "datawizard", "DBI", "dbplyr", "desc", "DescTools", "deSolve", "digest", "dipsaus", "dplyr", "DT", "e1071", "effectsize", "emmeans", "eRm", "estimability", "Exact", "expm", "FactoMineR", "fansi", "farver", "fastmap", "filearray", "freesurferformats", "fs", "future", "future.apply", "geometry", "gert", "ggrepel", "ggsci", "ggside", "ggstatsplot", "globals", "glue", "gmp", "gsw", "gt", "gtsummary", "haven", "hdf5r", "htmltools", "httpuv", "igraph", "insight", "jsonlite", "jtools", "kableExtra", "keras", "labelled", "later", "lavaan", "leaps", "listenv", "lme4", "markdown", "MatrixModels", "matrixStats", "mc2d", "metafor", "minqa", "modelbased", "modelsummary", "msm", "multcomp", "multcompView", "mvtnorm", "nloptr", "oce", "pak", "paletteer", "parallelly", "parameters", "patchwork", "pbdZMQ", "pbkrtest", "performance", "pkgbuild", "pkgfilecache", "pkgload", "PMCMRplus", "prismatic", "pROC", "processx", "profvis", "promises", "ps", "psych", "quantreg", "R.oo", "ragg", "ravetools", "Rcpp", "RcppArmadillo", "RcppEigen", "RcppParallel", "reactR", "readr", "remotes", "renv", "report", "repr", "reprex", "reticulate", "rlang", "Rmpfr", "RNifti", "RNiftyReg", "rprojroot", "rsconnect", "rstantools", "rstudioapi", "Rvcg", "rvest", "s2", "sandwich", "sass", "see", "servr", "sf", "shiny", "signal", "SparseM", "statsExpressions", "stringi", "SuppDists", "svglite", "systemfonts", "tables", "TAM", "targets", "tensorflow", "testthat", "textshaping", "tfruns", "tidyr", "timechange", "utf8", "uuid", "V8", "vctrs", "viridis", "vroom", "waldo", "waveslim", "wk", "writexl", "WRS2", "XML", "xml2", "yaml"))
install.packages(c("admisc", "afex", "backports", "BayesFactor", "bayestestR", "BH", "bit", "bitops", "brio", "broom", "broom.helpers", "BWStest", "cachem", "callr", "checkmate", "cli", "coda", "colorspace", "commonmark", "correlation", "corrplot", "cowplot", "curl", "data.table", "datawizard", "DBI", "dbplyr", "desc", "DescTools", "deSolve", "digest", "dipsaus", "dplyr", "DT", "e1071", "effectsize", "emmeans", "eRm", "estimability", "Exact", "expm", "FactoMineR", "fansi", "farver", "fastmap", "filearray", "freesurferformats", "fs", "future", "future.apply", "geometry", "gert", "ggrepel", "ggsci", "ggside", "ggstatsplot", "globals", "glue", "gmp", "gsw", "gt", "gtsummary", "haven", "hdf5r", "htmltools", "httpuv", "igraph", "insight", "jsonlite", "jtools", "kableExtra", "keras", "labelled", "later", "lavaan", "leaps", "listenv", "lme4", "markdown", "MatrixModels", "matrixStats", "mc2d", "metafor", "minqa", "modelbased", "modelsummary", "msm", "multcomp", "multcompView", "mvtnorm", "nloptr", "oce", "pak", "paletteer", "parallelly", "parameters", "patchwork", "pbdZMQ", "pbkrtest", "performance", "pkgbuild", "pkgfilecache", "pkgload", "PMCMRplus", "prismatic", "pROC", "processx", "profvis", "promises", "ps", "psych", "quantreg", "R.oo", "ragg", "ravetools", "Rcpp", "RcppArmadillo", "RcppEigen", "RcppParallel", "reactR", "readr", "remotes", "renv", "report", "repr", "reprex", "reticulate", "rlang", "Rmpfr", "RNifti", "RNiftyReg", "rprojroot", "rsconnect", "rstantools", "rstudioapi", "Rvcg", "rvest", "s2", "sandwich", "sass", "see", "servr", "sf", "shiny", "signal", "SparseM", "statsExpressions", "stringi", "SuppDists", "svglite", "systemfonts", "tables", "TAM", "targets", "tensorflow", "testthat", "textshaping", "tfruns", "tidyr", "timechange", "utf8", "uuid", "V8", "vctrs", "viridis", "vroom", "waldo", "waveslim", "wk", "writexl", "WRS2", "XML", "xml2", "yaml"))
install.packages("htmltools")
install.packages("htmltools")
install.packages("htmltools")
library(ChestVolume)
library(ChestVolume)
if (!requireNamespace("devtools", quietly = TRUE)) {
install.packages("devtools")
}
devtools::install_github("PKwong86/ChestVolume")
library(ChestVolume)
devtools::build_vignettes()
devtools::build_vignettes()
install.packages("devtools")
devtools::build_vignettes()
packageVersion("htmltools")
remotes::install_github("rstudio/htmltools")
devtools::build_vignettes()
library(ChestVolume)
library(ChestVolume)
data(sample_data)
processed_data <- process_marker_data(sample_data, convert_to_cm = TRUE)
install.packages("htmltools")
library(ChestVolume)
library(ChestVolume)
if (!requireNamespace("devtools", quietly = TRUE)) {
install.packages("devtools")
}
devtools::install_github("PKwong86/ChestVolume")
if (!requireNamespace("devtools", quietly = TRUE)) {
install.packages("devtools")
}
devtools::install_github("PKwong86/ChestVolume")
if (!requireNamespace("devtools", quietly = TRUE)) {
install.packages("devtools")
}
devtools::install_github("PKwong86/ChestVolume")
library(ChestVolume)
knitr::kable(head(sample_data[, 1:6]), "pipe")
library(ChestVolume)
knitr::kable(head(sample_data[, 1:6]), "pipe")
segments <- list(
upper_left = c("M01", "M02", "M04", "M05","M07", "M08","M10", "M11")
)
calculate_volumes(adjusted_data, segments)
segments <- list(
upper_left = c("M01", "M02", "M04", "M05","M07", "M08","M10", "M11")
)
volumes<- calculate_volumes(adjusted_data, segments)
# Adjust the marker positions by moving them 1 cm toward the chest center
adjusted_data <- adj_position(processed_data, distance = 1)
data(sample_data)
processed_data <- process_marker_data(sample_data, convert_to_cm = TRUE)
head(processed_data)
data(sample_data)
processed_data <- process_marker_data(sample_data, convert_to_cm = TRUE)
head(processed_data)
# Adjust the marker positions by moving them 1 cm toward the chest center
adjusted_data <- adj_position(processed_data, distance = 1)
head(adjusted_data)
segments <- list(
upper_left = c("M01", "M02", "M04", "M05","M07", "M08","M10", "M11")
)
volumes<- calculate_volumes(adjusted_data, segments)
head(volumes)
plot_chest_3d(adjusted_data, segments, selected_segment = 'upper_left')
plot_2d_volume(volumes, 'Segment')
plot_chest_3d(adjusted_data, segments, selected_segment = 'upper_left')
devtools::check()
devtools::check(build_vignettes = FALSE)
library(ChestVolume)
library(devtools)
devtools::install_github("PKwong86/ChestVolume")
library(ChestVolume)
requireNamespace()
devtools::document()
setwd("C:/Users/user/Dropbox/r script/ChestVolume/ChestVolume/inst/extdata")
read_segment_definitions('segment_def.xlsx')
Segment_example <- read_segment_definitions('segment_def.xlsx')
setwd("C:/Users/user/Dropbox/r script/ChestVolume/ChestVolume")
save(Segment_example, file = "data/Segment_example.rda")
View(Segment_example)
# Example sample input data
data(sample_data)
# Step 1: Process the marker data and convert from mm to cm
processed_data <- process_marker_data(sample_data, convert_to_cm = TRUE)
# Step 2: Adjust the marker positions by moving them 1 cm toward the chest center
adjusted_data <- adj_position(processed_data, distance = 1)
# Step 3: Define the chest segments (example with one segment)
segments <- list(
left = c("M01", "M02", "M03", "M04","M05", "M06","M07", "M08",
"M09", "M10", "M11","M12", "M13","M14", "M15","M16", "M17")
)
# Step 4: Calculate the chest segment volumes
calculate_volumns(adjusted_data, segments)
# Step 4: Calculate the chest segment volumes
calculate_volumne(adjusted_data, segments)
# Step 4: Calculate the chest segment volumes
calculate_volume(adjusted_data, segments)
# Step 4: Calculate the chest segment volumes
calculate_volumes(adjusted_data, segments)
# Step 5: Visualize the chest expansion in 3D
plot_chest_3d(adjusted_data, segments, selected_segment = 'left')
data(sample_data)
# Step 1: Process the marker data and convert from mm to cm
processed_data <- process_marker_data(sample_data, convert_to_cm = TRUE)
# Step 2: Adjust the marker positions by moving them 1 cm toward the chest center
adjusted_data <- adj_position(processed_data, distance = 1)
# Step 3: Define the chest segments (example with one segment)
segments <- list(
left = c("M01", "M02", "M03", "M04","M05", "M06","M07", "M08",
"M09", "M10", "M11","M12", "M13","M14", "M15","M16", "M17","M18")
)
# Step 4: Calculate the chest segment volumes
calculate_volumes(adjusted_data, segments)
# Step 5: Visualize the chest expansion in 3D
plot_chest_3d(adjusted_data, segments, selected_segment = 'left')
# Step 6: Plot the chest volume changes over time
plot_2d_volume(volumes, 'Segment')
# Step 4: Calculate the chest segment volumes
volumes<- calculate_volumes(adjusted_data, segments)
head(volumes)
# Step 5: Visualize the chest expansion in 3D
plot_chest_3d(adjusted_data, segments, selected_segment = 'left')
# Step 6: Plot the chest volume changes over time
plot_2d_volume(volumes, 'Segment')
# Example sample input data
data(sample_data)
# Step 1: Process the marker data and convert from mm to cm
processed_data <- process_marker_data(sample_data, convert_to_cm = TRUE)
# Step 2: Adjust the marker positions by moving them 1 cm toward the chest center
adjusted_data <- adj_position(processed_data, distance = 1)
# Step 3: Define the chest segments (example with one segment)
segments <- list(
left = c("M01", "M02", "M03", "M04","M05", "M06","M07", "M08",
"M09", "M10", "M11","M12", "M13","M14", "M15","M16", "M17","M18")
)
# Step 4: Calculate the chest segment volumes
volumes<- calculate_volumes(adjusted_data, segments)
head(volumes)
# Step 5: Visualize the chest expansion in 3D
plot_chest_3d(adjusted_data, segments, selected_segment = 'left')
# Step 6: Plot the chest volume changes over time
plot_2d_volume(volumes, 'Segment')
# Step 5: Visualize the chest expansion in 3D
plot_chest_3d(adjusted_data, segments, selected_segment = 'left')
